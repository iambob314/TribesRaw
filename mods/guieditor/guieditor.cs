//
// GUI Editor mod. Can run standalone with -mod guieditor, or attach to existing window
// with requireMod and GuiEditor::attach.
//
// TODO: editBox / openFile / saveFile for better dialogs?
//

//
// Controls:
//
// SimGui::TextEdit
// SimGui::SimpleText: Alignable, setValue()able
// SimGui::ScrollCtrl: scrollbox
// METextEdit
// MEButton
// FearGUI::FGBitmapCtrl: displays a PBMP, stretched to fit
// FearGUI::FGPaletteCtrl: force palette (good one = IDPAL_SHELL, use inspector to set)
// FearGUI::FGTextList: selection list

requireMod(std);
requireMod(gui);

// GuiEditor::standalone starts a standalone guieditor (creates a window, loads a basic GUI)
// Called when this mod is run in standalone mode (-mod guieditor). May also be called
// explicitly from another mod, if desired.
function GuiEditor::standalone() {
	focusClient();

	if (!isObject($MainWindow)) {
		GUI::newWindow($MainWindow);
		GuiEditor::newGUI(testing, FearGUI::FGBitmapCtrl);
	}

	schedule("GuiEditor::loadEditor(true);", 0);
}

function GuiEditor::attach(%guiObj) {
	if (!isObject(%guiObj)) {
		echo("must call GuiEditor::attach on a live GUI object, usually a root content control");
		return false;
	}		
	
	$GuiEditor::editTarget = %guiObj;
	schedule("GuiEditor::loadEditor();", 0);
	return true;
}



$MainWindow = MainWindow;
// $GuiEditor::lastControlID = incrementing counter (for autogenerated control IDs)

$GuiEditor::allControls = "SimGui::TextEdit SimGui::SimpleText SimGui::ScrollCtrl " @
	"FearGUI::FGBitmapCtrl FearGUI::FGPaletteCtrl FearGUI::FGTextList " @
	"METextEdit MEButton";

//
// Load/save GUI editor itself
//

function wow(%t) {
	%x = loadObject(testing, "temp\\guiEditorToolTray.gui");
	for (%i = 0; %i < %t; %i++) {
		%del = Group::getObject(testing, %i);
		echos("deleteObject", %del, getObjectType(%del), Object::getName(%del));
		deleteObject(%del);
	}
	storeObject(testing, "temp\\wow.gui");
	
	base::refreshSearchPath();
	newObject(ToolTrayWindow, SimGui::Canvas, "GUI Editor Tools", 160, 480, True);
	GuiLoadContentCtrl(ToolTrayWindow, "temp\\wow.gui");
}

// GuiEditor::loadEditor creates the GUI editor tool tray.
// If %fixPalette, it will also impose the shell palette (use only if attaching
// to non-in-game UI, otherwise Tribes will crash...).
function GuiEditor::loadEditor(%fixPalette) {
	newObject(ToolTrayWindow, SimGui::Canvas, "GUI Editor Tools", 160, 480, True);
	GuiLoadContentCtrl(ToolTrayWindow, "guieditor\\guiEditorToolTray.gui");
	
	// Stupid hack: we need to load shellpal.gui somewhere, but apparently
	// it doesn't "take effect" (call loadPalette() in C++) unless loaded as
	// top-level GUI (or if we hit Apply in inspector, but we can't automate that).
	// So, make a tiny temp window, load the palette-setter, then delete it.
	if (%fixPalette) {
		newObject(tmpWin, SimGui::Canvas, "", 0, 0, False);
		GuiLoadContentCtrl(tmpWin, "guieditor\\shellpal.gui");
		deleteObject(tmpWin);
	}
		
	windowsKeyboardEnable(ToolTrayWindow);
	windowsMouseEnable(ToolTrayWindow);
	cursorOn(ToolTrayWindow);

	Control::setValue(GUIFileField, "");
	GuiEditor::updateEditModeButton();
	GuiEditor::initCreateList();
}

function GuiEditor::saveEditor() {
	GuiSaveContentCtrl(ToolTrayWindow, "temp\\guiEditorToolTray.gui");
}

function GuiEditor::editEditor() {
	GuiEditMode(ToolTrayWindow);
	GuiInspect(ToolTrayWindow);
	GuiEditor::openTree();
	simTreeAddSet(guiEditorTree, "GuiEditorToolTrayGui");
}

//
// Load/save a new GUI project
//

$GuiEditor::editTarget = ""; // the control under edit (e.g. playGui)

function GuiEditor::newGUI(%guiName, %compType) {
	%guiObjName = %guiName @ "Gui";

	echo("Creating new GUI as ", %compType);
	GuiNewContentCtrl($MainWindow, %compType);
	if (isObject(%guiObjName)) deleteObject(%guiObjName); // make sure no existing one lingering
	GuiSaveContentCtrl($MainWindow, "temp\\" @ %guiName @ ".gui");
	GuiLoadContentCtrl($MainWindow, "temp\\" @ %guiName @ ".gui");
	
	%success = isObject(%guiObjName);
	$GuiEditor::editTarget = tern(%success, %guiObjName, "");
	return %success;
}

function GuiEditor::loadGUI(%file) {
	%guiName = File::getBase(%file);
	%guiObjName = %guiName @ "Gui";

	GuiNewContentCtrl($MainWindow, FearGUI::FGBitmapCtrl);
	if (isObject(%guiObjName)) deleteObject(%guiObjName); // make sure no existing one lingering

	echo("Loading GUI from ", %file);
	GuiLoadContentCtrl(%MainWindow, %file);

	%success = isObject(%guiObjName);
	$GuiEditor::editTarget = tern(%success, %guiObjName, "");
	return %success;
}

function GuiEditor::saveGUI(%file) {
	echo("Saving GUI to ", %file);
	GuiSaveContentCtrl($MainWindow, %file);
	$ConsoleWorld::DefaultSearchPath = $ConsoleWorld::DefaultSearchPath;
	return true;
}

//
// GUI editor functionality (wiring to editor buttons, etc. in next section)
//

function GuiEditor::openTree() {
	if (isObject(guiEditorTree)) return;
	if ($GuiEditor::editTarget == "") return;

	simTreeCreate(guiEditorTree, ToolTrayWindow);
	simTreeAddSet(guiEditorTree, $GuiEditor::editTarget);
}

function GuiEditor::openInspector() {
	GuiInspect($MainWindow);
}

function GuiEditor::toggleEditMode() {
	GuiEditMode($MainWindow);
	GuiEditor::updateEditModeButton();
}

function GuiEditor::initCreateList() {
	TextList::clear(GUICreateList);
	for (%i = 0; (%ctrl = getWord($GuiEditor::allControls, %i)) != -1; %i++)
		TextList::addLine(GUICreateList, %ctrl);

	FGTextList::sort(GUICreateList);
}

function GuiEditor::createControl(%className) {
	if ($GuiEditor::editTarget == "") return;
	
	%ctrl = Control::getValue(GUICreateList);
	if (%ctrl == "") return;

	GuiEditor::newControl($GuiEditor::editTarget, "", %ctrl);
}

function GuiEditor::newControl(%parent, %name, %className, %pos, %extent) {
	%pos = def(%pos, "0 0");
	%extent = def(%extent, "64 64");
	%name = def(%name, "Control" @ $GuiEditor::lastControlID++); // we *must* have a real name, because Control::* only accept names, not IDs
		
	%x = newObject(%name, %className);
	Control::setPosition(%name, getWord(%pos, 0), getWord(%pos, 1));
	Control::setExtent(%name, getWord(%extent, 0), getWord(%extent, 1));
	
	if (%className == "FearGui::FGTextList") { // special stupid bug: list must not be blank or Tribes crashes...
		TextList::addLine(%name, "entry");
		Control::setValue(%name, "entry");
	}
	
	addToSet(%parent, %x);
	GuiSetSelection($MainWindow, %x);
	return %x;
}

//
// GUI controls in editor window
//

function GuiEditor::updateEditModeButton() {
	Control::setText(GUIEditModeButton, tern(isObject(EditControl), "Enter GUI mode", "Enter EDIT mode"));
}

function GuiEditor::errorButton(%btn, %errmsg) {
	%oldmsg = Control::getText(%btn);
	if (%oldmsg == "") return;
	
	Control::setActive(%btn, false); Control::setText(%btn, %errmsg);
	schedule("Control::setText(\"" @ %btn @ "\", \"" @ %oldmsg @ "\"); Control::setActive(\"" @ %btn @ "\", true);", 3);
}

function GUINewButton::onAction() {
	%name = def(Control::getValue(GUIFileField), "New");
	%ctrl = def(Control::getValue(GUICreateList), "FearGUI::FGBitmapCtrl");

	%success = GuiEditor::newGUI(%name, %ctrl);
	GuiEditor::errorButton(GUINewButton, tern(%success, "Success", "Error"));
}

function GUILoadButton::onAction() {
	%file = Control::getValue(GUIFileField);
	if (!GuiEditor::loadGUI("temp\\" @ %file))
		GuiEditor::errorButton(GUILoadButton, "NOTFOUND");
}

function GUISaveButton::onAction() {
	%file = Control::getValue(GUIFileField);
	GuiEditor::saveGUI("temp\\" @ %file);
}

function GUIEditModeButton::onAction() {
	GuiEditor::toggleEditMode();
}

function GUIInspectorButton::onAction() {
	GuiEditor::openInspector();
}

function GUITreeButton::onAction() {
	GuiEditor::openTree();
}

function GUICreateButton::onAction() {
	if ((%ctrl = Control::getValue(GUICreateList)) == "") return;
	GuiEditor::createControl();
}

// GuiEditorToolTrayGui::onOpen is called when the tool tray is fully loaded
function GuiEditorToolTrayGui::onOpen() {
	GuiEditor::initCreateList();
}

// Finally, load up standalone mode if designated
if (%standalone) GuiEditor::standalone();